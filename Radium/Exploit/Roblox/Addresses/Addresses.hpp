#pragma once
#include <Windows.h>
#include <cstdint>
#include <string>
#include "../../Dependencies/oxorany/oxorany_include.h"

const std::uintptr_t BaseAddress = reinterpret_cast<std::uintptr_t>(GetModuleHandleA(0));

typedef struct lua_State;

namespace Radium
{
	namespace TypeDefinitions
	{
	//	using Print = std::uintptr_t(__fastcall*)(int, const char*, ...);
		using GetScheduler = std::uintptr_t(__fastcall*)();
		using GetGlobalState = std::uintptr_t(__fastcall*)(std::uintptr_t, int*, int*);
		using DecryptLuaState = std::uintptr_t(__fastcall*)(std::uintptr_t);
		using TaskDefer = std::uintptr_t(__fastcall*)(lua_State*);
	}

	namespace Addresses
	{
		namespace Internal // Basically these functions are used for things like internal engine functions (for example, GetScheduler and print)
		{
		//	const std::uintptr_t Print = BaseAddress + 0x9;
			const std::uintptr_t GetScheduler = BaseAddress + 0x2DD80A0; // updated
		}

		namespace Luau
		{
			const std::uintptr_t DummyNode = BaseAddress + 0x4112A28; // updated
			const std::uintptr_t NilObject = BaseAddress + 0x41132B8; // updated
			const std::uintptr_t Execute = BaseAddress + 0x2399150; // updated
		}

		namespace Extra
		{
			const std::uintptr_t GetGlobalState = BaseAddress + 0xD44D30;
			const std::uintptr_t DecryptLuaState = BaseAddress + 0xAFE360;
			const std::uintptr_t TaskDefer = BaseAddress + 0xED0220;

			const std::uintptr_t PushInstance = BaseAddress + 0xE2E890;
		}
	}

	namespace Offsets
	{
		namespace TaskScheduler
		{
			const std::uintptr_t JobStart = 408;
			const std::uintptr_t JobEnd = 416;
			const std::uintptr_t JobName = 144;

			const std::uintptr_t Fps = 376;
		}

		namespace WaitingHybridScriptsJob
		{
			const std::uintptr_t Sc = 504;
		}

		namespace ScriptContext
		{
			const std::uintptr_t Real = 280;
		}

		namespace GlobalState
		{
			const std::uintptr_t Decrypt = 136;
		}

		namespace Render
		{
			const std::uintptr_t RenderView = 0x218;
			const std::uintptr_t DeviceD3D11 = 0x8;
			const std::uintptr_t SwapChain = 0xA8;	
		}

		namespace Signal
		{
			const uintptr_t ScriptConnection = 0x1C;
			const uintptr_t NextSignal = 0x10;
			const uintptr_t State = 0x20;
		}
	}

	namespace Roblox
	{
		//inline TypeDefinitions::Print Print = reinterpret_cast<TypeDefinitions::Print>(Addresses::Internal::Print);
		inline TypeDefinitions::GetScheduler GetTaskScheduler = reinterpret_cast<TypeDefinitions::GetScheduler>(Addresses::Internal::GetScheduler);

		inline TypeDefinitions::GetGlobalState GetGlobalState = reinterpret_cast<TypeDefinitions::GetGlobalState>(Addresses::Extra::GetGlobalState);
		inline TypeDefinitions::DecryptLuaState DecryptLuaState = reinterpret_cast<TypeDefinitions::DecryptLuaState>(Addresses::Extra::DecryptLuaState);

		inline TypeDefinitions::TaskDefer TaskDefer = reinterpret_cast<TypeDefinitions::TaskDefer>(Addresses::Extra::TaskDefer);
	}
}

template<typename t> class vmvalue1
{
public:
	operator const t() const
	{
		return (t)((uintptr_t)storage - (uintptr_t)this);
	}

	void operator=(const t& value)
	{
		storage = (t)((uintptr_t)value + (uintptr_t)this);
	}

	const t operator->() const
	{
		return operator const t();
	}

private:
	t storage;
};

template<typename t> class vmvalue2
{
public:
	operator const t() const
	{
		return (t)((uintptr_t)this - (uintptr_t)storage);
	}

	void operator=(const t& value)
	{
		storage = (t)((uintptr_t)this - (uintptr_t)value);
	}

	const t operator->() const
	{
		return operator const t();
	}

private:
	t storage;
};


template<typename t> class vmvalue3
{
public:
	operator const t() const
	{
		return (t)((uintptr_t)this ^ (uintptr_t)storage);
	}

	void operator=(const t& value)
	{
		storage = (t)((uintptr_t)value ^ (uintptr_t)this);
	}

	const t operator->() const
	{
		return operator const t();
	}

private:
	t storage;
};

template<typename t> class vmvalue4
{
public:
	operator const t() const
	{
		return (t)((uintptr_t)this + (uintptr_t)storage);
	}

	void operator=(const t& value)
	{
		storage = (t)((uintptr_t)value - (uintptr_t)this);
	}

	const t operator->() const
	{
		return operator const t();
	}

private:
	t storage;
};

#define VM_SHUFFLE3(s, a1, a2, a3) a3 s a2 s a1
#define VM_SHUFFLE4(s, a1, a2, a3, a4) a4 s a2 s a3 s a1
#define VM_SHUFFLE5(s, a1, a2, a3, a4, a5) a5 s a2 s a4 s a3 s a1
#define VM_SHUFFLE6(s, a1, a2, a3, a4, a5, a6) a2 s a6 s a4 s a1 s a5 s a3
#define VM_SHUFFLE7(s, a1, a2, a3, a4, a5, a6, a7) a2 s a3 s a4 s a1 s a5 s a6 s a7
#define VM_SHUFFLE8(s, a1, a2, a3, a4, a5, a6, a7, a8) a8 s a2 s a7 s a1 s a4 s a6 s a5 s a3
#define VM_SHUFFLE9(s, a1, a2, a3, a4, a5, a6, a7, a8, a9) a4 s a5 s a9 s a8 s a7 s a6 s a1 s a3 s a2

#define ProtoMember1Enc vmvalue2
#define ProtoMember2Enc vmvalue3


#define ProtoDebugnameEnc vmvalue2
#define ProtoDebuginsnEnc vmvalue1
#define ProtoTypeInfoEnc vmvalue4

#define UdataMetaEnc vmvalue4

#define TStringLenEnc vmvalue4
#define TStringHashEnc vmvalue3


#define ClosureDebugnameEnc vmvalue3
#define ClosureContEnc vmvalue1
#define ClosureFuncEnc vmvalue2


#define TableMemberEnc vmvalue2

#define LuastateStacksizeEnc vmvalue4
#define LuastateGlobalEnc vmvalue4

#define GlobalstateTmnameEnc vmvalue4
#define GlobalstateTtnameEnc vmvalue4

#define Comma ,
#define Semicolon ;