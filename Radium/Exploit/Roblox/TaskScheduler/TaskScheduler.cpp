#include "TaskScheduler.hpp"

std::vector<std::uintptr_t> Radium::TaskScheduler::GetJobs()
{
	std::vector<std::uintptr_t> Jobs{};
	auto JobStart = *reinterpret_cast<uintptr_t**>(Roblox::GetTaskScheduler() + Offsets::TaskScheduler::JobStart);
	auto JobEnd = *reinterpret_cast<uintptr_t**>(Roblox::GetTaskScheduler() + Offsets::TaskScheduler::JobEnd);

	for (uintptr_t* Job = JobStart; Job != JobEnd; Job += 2)
	{
		Jobs.push_back(*Job);
	}

	return Jobs;
}

std::uintptr_t Radium::TaskScheduler::GetJobByName(std::string Name)
{
	for (uintptr_t Job : GetJobs())
	{
		auto JobName = *reinterpret_cast<std::string*>(Job + Offsets::TaskScheduler::JobName);

		if (JobName == Name)
		{
			return Job;
		}
	}

	return 0;
}

std::uintptr_t Radium::TaskScheduler::GetScriptContext()
{
	return *reinterpret_cast<uintptr_t*>(GetJobByName(oxorany("WaitingHybridScriptsJob")) + Offsets::WaitingHybridScriptsJob::Sc) + Offsets::ScriptContext::Real;
}


std::uintptr_t Radium::TaskScheduler::GetLuaState()
{
	int Identity = 0;

	int Script = 0;

	auto EncryptedLuaState = Radium::Roblox::GetGlobalState(GetScriptContext(), &Identity, &Script);

	return Radium::Roblox::DecryptLuaState(EncryptedLuaState + Offsets::GlobalState::Decrypt);
}

void Radium::TaskScheduler::SetFpsCap(double Fps)
{
	*reinterpret_cast<double*>(Roblox::GetTaskScheduler() + Offsets::TaskScheduler::Fps) = 1 / Fps;
}