/* NOTE: This exploit is just a learners exploit, just to experiment and learn about Luau internals
*/

#include "Script.hpp"
#include <Luau/Compiler.h>
#include <cpr/cpr.h>
#include "../../Roblox/Security/Security.hpp"
#include "../../Dependencies/Luau/VM//src/lgc.h"
#include "../../Dependencies/Luau/VM//src/lapi.h"
#include <lualib.h>
#include "../../../Dependencies/Luau/VM/src/lmem.h"

#define RegisterFunction(L, Func, Name) lua_pushcclosure(L, Func, Name, 0); \
lua_setglobal(L, Name);

#define RegisterMember(L, Func, Name) lua_pushcclosure(L, Func, Name, 0); \
lua_setfield(L, -2, Name);

int GetGenv(lua_State* L)
{
	lua_pushvalue(L, LUA_GLOBALSINDEX);
	return 1; // Return 1 value which is our globals table
}

int GetRenv(lua_State* L)
{
	lua_pushvalue(reinterpret_cast<lua_State*>(Radium::TaskScheduler::GetLuaState()), LUA_GLOBALSINDEX);
	lua_xmove(reinterpret_cast<lua_State*>(Radium::TaskScheduler::GetLuaState()), L, 1);
	return 1; // Return 1 value which is our globals table
}

int HttpGet(lua_State* L) // We are defining this here, because we have the namecall hook here in this file, and I don't wanna create an extra file just to categorize it
{
	auto Url = lua_tostring(L, 1); // 2 because the second argument in the namecall hook is the URL

	auto Result = cpr::Get(cpr::Url{ Url });

	lua_pushstring(L, Result.text.c_str());
	return 1;
}

int GetObjects(lua_State* L)
{
	lua_getglobal(L, "game");
	lua_getfield(L, -1, "GetService");
	lua_pushvalue(L, -2);
	lua_pushstring(L, "InsertService");
	lua_pcall(L, 2, 1, 0);

	lua_getfield(L, -1, "LoadLocalAsset");
	lua_pushvalue(L, -2);
	lua_pushstring(L, lua_tostring(L, 1));
	lua_pcall(L, 2, 1, 0); // Call the function, returns at index -1

	lua_newtable(L);	// New table, index -1, object at index -2
	lua_pushvalue(L, -2); // push the object onto the stack
	lua_rawseti(L, -2, 1); // push the object into index 1 in the table 

	return 1; // return the table
}

int CompareInstances(lua_State* L)
{
	luaL_checktype(L, 1, LUA_TUSERDATA);

	auto Inst1 = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(L, 1));
	auto Inst2 = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(L, 2));

	lua_pushboolean(L, (Inst1 == Inst2));
	return 1;
}

// My shitty attempt at GetGC

typedef struct
{
	lua_State* pLua;
	bool accessTables;
	int itemsFound;
} GCOContext;

// GetGc - returns a table with all the objects in the garbage collector
// What we learn from this:
// How objects are stored in the garbage collector
// How to store objects on the lua stack

int GetGc(lua_State* L)
{
	auto AccessTables = lua_toboolean(L, 1);

	lua_newtable(L);

	GCOContext Gcc{ L, AccessTables, 0 };

	auto OldGcState = L->global->gcstate;

	L->global->gcstate = -1; // Pause the GC

	luaM_visitgco(L, &Gcc, [](void* context, lua_Page* page, GCObject* gco) {
		auto Ctx = reinterpret_cast<GCOContext*>(context);
		lua_State* GL = Ctx->pLua;

		if (isdead(GL->global, gco))
		{
			return false;
		}

		if (gco->gch.tt == LUA_TFUNCTION || gco->gch.tt == LUA_TUSERDATA || gco->gch.tt == LUA_TTABLE && Ctx->accessTables == true)
		{
			GL->top->value.gc = gco; // Copy the gco
			GL->top->tt = gco->gch.tt; // Copy the type
			incr_top(GL); // Increment the top so we can have space for the item

			lua_rawseti(GL, -2, ++Ctx->itemsFound); // Set the values in the table, ++Cxt->itemsFound so we extract the index of the itemsFound and incriment the value.
		}

		return false;
		});

	L->global->gcstate = OldGcState; // Resume the GC

	return 1;
}

int GetNameCallMethod(lua_State* L)
{
	lua_pushstring(L, L->namecall->data);
	return 1;
}

int tester(lua_State* L)
{
	lua_pushnumber(L, 2235);
	return 1;
}

lua_CFunction OldIndex{};
lua_CFunction OldNamecall{};

void print(lua_State* L, const char* a2)
{
	lua_getglobal(L, "print");
	lua_pushstring(L, a2);
	lua_call(L, 1, 0);
}

int NewIndex(lua_State* L)
{
	if (Radium::Security::GetIdentity(L) == 8)
	{
		auto Method = std::string(lua_tostring(L, 2));

		if (Method == "HttpGet" || Method == "HttpGetAsync")
		{
			lua_pushcclosure(L, HttpGet, nullptr, 0);
			return 1;
		} 
		else if (Method == "GetObjects")
		{
			lua_pushcclosure(L, GetObjects, nullptr, 0);
			return 1;
		}
	}

	return OldIndex(L);
}

int NewNamecall(lua_State* L)
{
	if (Radium::Security::GetIdentity(L) == 8)
	{
		auto NM = std::string(L->namecall->data);


		if (NM == "HttpGet" || NM == "HttpGetAsync")
		{
			lua_pushcclosure(L, HttpGet, nullptr , 0);
			lua_pushstring(L, lua_tostring(L, 2));
			lua_pcall(L, 1, 1, 0);
			return 1;
		}
		else if (NM == "GetObjects")
		{
			lua_pushcclosure(L, GetObjects, nullptr, 0);
			lua_pushstring(L, lua_tostring(L, 2));
			lua_pcall(L, 1, 1, 0);
			return 1; 
		}
	}

	return OldNamecall(L);
}

//int cloneref(lua_State* State)
//{
//	luaL_checktype(State, 1, LUA_TUSERDATA);
//
//	const auto Original = uvalue(index2addr(State, 1));
//	lua_newuserdatatagged(State, Original->len, Original->tag);
//
//	const auto Clone = uvalue(index2addr(State, -1));
//	Clone->metatable = (Table*)Original->metatable;
//
//	*reinterpret_cast<uintptr_t*>(Clone->data) = *reinterpret_cast<uintptr_t*>(Original->data);
//	Clone->dummy.u = Original->dummy.u;
//
//	return 1;
//}

//int Replace(lua_State* L) 
//{
//	auto Obj = *reinterpret_cast<uintptr_t*>(lua_touserdata(L, 1)); // Our instance
//
//	lua_pushlightuserdata(L, reinterpret_cast<void*>(Radium::Addresses::Extra::PushInstance)); // Instance list
//	lua_rawget(L, LUA_REGISTRYINDEX); // Grab the registry table
//	lua_pushlightuserdata(L, (void*)Obj); // Push the object to find the Instance in the registry table
//	lua_pushvalue(L, 2); // push the second arg 
//	lua_rawset(L, -3); // set the 2nd arg in the registry
//	return 1;
//}

void Radium::Environment::Script::Register(lua_State* L)
{
	RegisterFunction(L, GetGenv, "getgenv");
	RegisterFunction(L, GetRenv, "getrenv");
	RegisterFunction(L, GetNameCallMethod, "getnamecallmethod");


	// Instance
		
	RegisterFunction(L, CompareInstances, "compareinstances");	

	// Gc

	RegisterFunction(L, GetGc, "getgc");

	lua_pop(L, lua_gettop(L));

	lua_getglobal(L, "game");
	lua_getmetatable(L, -1);
	lua_rawgetfield(L, -1, "__namecall");
	auto Cl = clvalue(index2addr(L, -1));
	OldNamecall = Cl->c.f;
	Cl->c.f = NewNamecall;
	lua_pop(L, 1);

	lua_rawgetfield(L, -1, "__index");
	auto Cl2 = clvalue(index2addr(L, -1));
	OldIndex = Cl2->c.f;
	Cl2->c.f = NewIndex;
	lua_pop(L, 1);

	lua_pop(L, 2);
}