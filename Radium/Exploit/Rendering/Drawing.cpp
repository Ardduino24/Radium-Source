#include "Drawing.h"
#include <lualib.h>
#include "imgui_internal.h"
#include "imgui_impl_dx11.h"
#include "imgui_impl_win32.h"
#include "imgui_impl_win32.h"
#include "imstb_truetype.h"
#include "imgui_impl_dx9.h"

void PushColor3(lua_State* L, ImVec4 Color)
{
    lua_getglobal(L, "Color3");
    lua_getfield(L, -1, "new");

    lua_pushnumber(L, Color.x);
    lua_pushnumber(L, Color.y);
    lua_pushnumber(L, Color.z);

    lua_call(L, 3, 1);
}

ImVec2 ToVec2(lua_State* state, int index)
{
    return *reinterpret_cast<const ImVec2*>(lua_topointer(state, index));
}

void PushVector2(lua_State* L, float X, float Y)
{
    lua_getglobal(L, "Vector2");
    lua_getfield(L, -1, "new");

    lua_pushnumber(L, X);
    lua_pushnumber(L, Y);

    lua_call(L, 2, 1);
}

int DestroyObj(lua_State* L)
{
    auto Obj = *reinterpret_cast<BaseDrawing**>(lua_touserdata(L, 1));

    if (Obj->Type == 1) // Line
    {
        if (const auto iter = std::find(Radium::Drawing::RenderingLines.begin(), Radium::Drawing::RenderingLines.end(), Obj); iter != Radium::Drawing::RenderingLines.end())
            Radium::Drawing::RenderingLines.erase(iter);
    } 
    else   if (Obj->Type == 2) // Text
    {
        if (const auto iter = std::find(Radium::Drawing::RenderingText.begin(), Radium::Drawing::RenderingText.end(), Obj); iter != Radium::Drawing::RenderingText.end())
            Radium::Drawing::RenderingText.erase(iter);
    }
    else if (Obj->Type == 3) // Circle
    {
        if (const auto iter = std::find(Radium::Drawing::RenderingCircles.begin(), Radium::Drawing::RenderingCircles.end(), Obj); iter != Radium::Drawing::RenderingCircles.end())
            Radium::Drawing::RenderingCircles.erase(iter);
    }
    else if (Obj->Type == 4) // Square
    {
        if (const auto iter = std::find(Radium::Drawing::RenderingSquare.begin(), Radium::Drawing::RenderingSquare.end(), Obj); iter != Radium::Drawing::RenderingSquare.end())
            Radium::Drawing::RenderingSquare.erase(iter);
    }
    else if (Obj->Type = 5) // Quad
    {
        if (const auto iter = std::find(Radium::Drawing::RenderingQuads.begin(), Radium::Drawing::RenderingQuads.end(), Obj); iter != Radium::Drawing::RenderingQuads.end())
            Radium::Drawing::RenderingQuads.erase(iter);
    }

    return 0;
}

int BaseIndex(lua_State* L, BaseDrawing* Bd, const char* Method)
{
    if (strcmp(Method, "Visible") == 0)
    {
        lua_pushboolean(L, Bd->Visible);
    } 
    else if (strcmp(Method, "Transparency") == 0)
    {
        lua_pushnumber(L, (float)Bd->Transparency);
    }
    else if (strcmp(Method, "Color") == 0)
    {
        PushColor3(L, Bd->Color);
    } 
    else if (strcmp(Method, "Destroy") == 0)
    {
        lua_pushcclosure(L, DestroyObj, "", 0);
    }

    return 1;
}

int BaseNewIndex(lua_State* L, BaseDrawing* Bd, const char* Method)
{
    if (strcmp(Method, "Visible") == 0)
    {
        Bd->Visible = lua_toboolean(L, 3);
    }
    else if (strcmp(Method, "Transparency") == 0)
    {
        Bd->Transparency = (float)lua_tonumber(L, 3);
    } 
    else if (strcmp(Method, "Color") == 0)
    {
        auto ColorObj = reinterpret_cast<Color_t*>(lua_touserdata(L, 3));
        Bd->Color = ImVec4(ColorObj->R, ColorObj->G, ColorObj->B, Bd->Transparency);
    }

    return 1;
}

int TextIndex(lua_State* L)
{
    auto Method = lua_tostring(L, 2);


    const auto Object = *reinterpret_cast<Text_t**>(lua_touserdata(L, 1));

    if (strcmp(Method, "Text") == 0)
    {
        lua_pushstring(L, Object->Data);
    }
    else if (strcmp(Method, "Position") == 0)
    {
        PushVector2(L, Object->Position.x, Object->Position.y);
    }
    else if (strcmp(Method, "Size") == 0)
    {
        lua_pushnumber(L, Object->Size);
    }
    else if (strcmp(Method, "Center") == 0)
    {
        lua_pushboolean(L, Object->Centered);
    }
    else if (strcmp(Method, "Font") == 0)
    {
        lua_pushnumber(L, Object->Font);
    }
    else if (strcmp(Method, "TextBounds") == 0)
    {
        PushVector2(L, Object->TextBounds.x, Object->TextBounds.y);
    }
    else if (strcmp(Method, "Outline") == 0)
    {
        lua_pushboolean(L, Object->Outline);
    }

    BaseIndex(L, Object, Method);

    return 1;
}

int TextNewIndex(lua_State* L)
{

    auto Method = lua_tostring(L, 2);


    const auto Object = *reinterpret_cast<Text_t**>(lua_touserdata(L, 1));

    if (strcmp(Method, "Text") == 0)
    {
        size_t Len{};
        const char* str = luaL_checklstring(L, 3, &Len);
        
        std::strcpy(Object->Data, str);
    }
    else if (strcmp(Method, "Position") == 0)
    {
        Object->Position = ToVec2(L, 3);
    }
    else if (strcmp(Method, "Size") == 0)
    {
        auto Size = lua_tonumber(L, 3);
        Object->Size = (float)Size;    
    }
    else if (strcmp(Method, "Center") == 0)
    {
        auto Center = lua_toboolean(L, 3);
        Object->Centered = Center;
    }
    else if (strcmp(Method, "Font") == 0)
    {
        auto Font = lua_tonumber(L, 3);
        Object->Font = Font;
    }
    else if (strcmp(Method, "TextBounds") == 0)
    {
        Object->TextBounds = ToVec2(L, 3);
    }
    else if (strcmp(Method, "Outline") == 0)
    {
        auto Outline = lua_toboolean(L, 3);
        Object->Outline = Outline;
    }
    else if (strcmp(Method, "ZIndex") == 0)
    {
        auto ZIndex = lua_tonumber(L, 3);
        Object->ZIndex = ZIndex;
    }

    BaseNewIndex(L, Object, Method);

    return 0;
}

int LineIndex(lua_State* L)
{
    auto Ud = reinterpret_cast<void*>(lua_touserdata(L, 1));
    auto Method = lua_tostring(L, 2);


    const auto Object = *reinterpret_cast<Line_t**>(lua_touserdata(L, 1));

    if (strcmp(Method, "To") == 0)
    {
        PushVector2(L, Object->To.x, Object->To.y);
    } 
    else if (strcmp(Method, "From") == 0)
    {
        PushVector2(L, Object->From.x, Object->From.y);
    }
    else if (strcmp(Method, "Thickness") == 0)
    {
        lua_pushnumber(L, Object->Thickness);
    }

    BaseIndex(L, Object, Method);

    return 1;
}

int LineNewIndex(lua_State* L)
{
    auto Ud = reinterpret_cast<void*>(lua_touserdata(L, 1));
    auto Method = lua_tostring(L, 2);

    const auto Object = *reinterpret_cast<Line_t**>(lua_touserdata(L, 1));

    if (strcmp(Method, "To") == 0)
    {
        Object->To = ToVec2(L, 3);
    }
    else if (strcmp(Method, "From") == 0)
    {
        Object->From = ToVec2(L, 3);
    }
    else if (strcmp(Method, "Thickness") == 0)
    {
        Object->Thickness = (float)lua_tonumber(L, 3);
    }

    BaseNewIndex(L, Object, Method);

    return 0;
}

int CircleIndex(lua_State* L)
{
    auto Method = lua_tostring(L, 2);

    const auto Object = *reinterpret_cast<Circle_t**>(lua_touserdata(L, 1));

    if (strcmp(Method, "NumSides") == 0)
    {
        lua_pushnumber(L, Object->NumSides);
    }
    else if (strcmp(Method, "Radius") == 0)
    {
        lua_pushnumber(L, Object->Radius);
    }
    else if (strcmp(Method, "Position") == 0)
    {
        PushVector2(L, Object->Position.x, Object->Position.y);
    }
    else if (strcmp(Method, "Filled") == 0)
    {
        lua_pushboolean(L, Object->Filled);
    }
    else if (strcmp(Method, "Thickness") == 0)
    {
        lua_pushnumber(L, Object->thickness);
    }

    BaseIndex(L, Object, Method);

    return 1;
}

int CircleNewIndex(lua_State* L)
{
    auto Method = lua_tostring(L, 2);


    const auto Object = *reinterpret_cast<Circle_t**>(lua_touserdata(L, 1));

    if (strcmp(Method, "NumSides") == 0)
    {
        Object->NumSides = lua_tonumber(L, 3);
    }
    else if (strcmp(Method, "Radius") == 0)
    {
        Object->Radius = (float)lua_tonumber(L, 3);
    }
    else if (strcmp(Method, "Position") == 0)
    {
        Object->Position = ToVec2(L, 3);
    }
    else if (strcmp(Method, "Filled") == 0)
    {
        Object->Filled = lua_toboolean(L, 3);
    }
    else if (strcmp(Method, "Thickness") == 0)
    {
        Object->thickness = (float)lua_tonumber(L, 3);
    }

    BaseNewIndex(L, Object, Method);

    return 0;
}

int SquareIndex(lua_State* L)
{
    auto Ud = reinterpret_cast<void*>(lua_touserdata(L, 1));
    auto Method = lua_tostring(L, 2);



    const auto Object = *reinterpret_cast<Square_t**>(lua_touserdata(L, 1));

    if (strcmp(Method, "Thickness") == 0)
    {
        lua_pushnumber(L, Object->Thickness);
    }
    else if (strcmp(Method, "Size") == 0)
    {
        PushVector2(L, Object->Size.x, Object->Size.y);
    }
    else if (strcmp(Method, "Position") == 0)
    {
        PushVector2(L, Object->Position.x, Object->Position.y);
    }
    else if (strcmp(Method, "Filled") == 0)
    {
        lua_pushboolean(L, Object->Filled);
    }

    BaseIndex(L, Object, Method);

    return 1;
}

int SquareNewIndex(lua_State* L)
{
    const auto Object = *reinterpret_cast<Square_t**>(lua_touserdata(L, 1));

    auto Method = lua_tostring(L, 2);

    if (strcmp(Method, "Thickness") == 0)
    {
        Object->Thickness = (float)lua_tonumber(L, 3);
    }
    else if (strcmp(Method, "Size") == 0)
    {
        Object->Size = ToVec2(L, 3);
    }
    else if (strcmp(Method, "Position") == 0)
    {
        Object->Position = ToVec2(L, 3);
    }
    else if (strcmp(Method, "Filled") == 0)
    {
        Object->Filled = lua_toboolean(L, 3);
    }

    BaseNewIndex(L, Object, Method);

    return 0;
}

int QuadIndex(lua_State* L)
{
    auto Ud = reinterpret_cast<void*>(lua_touserdata(L, 1));
    auto Method = lua_tostring(L, 2);

    const auto Object = *reinterpret_cast<Quad_t**>(lua_touserdata(L, 1));

    if (strcmp(Method, "PointA") == 0)
    {
        PushVector2(L, Object->PointA.x, Object->PointA.y);
    }
    else if (strcmp(Method, "PointA") == 0)
    {
        PushVector2(L, Object->PointB.x, Object->PointB.y);
    }
    else if (strcmp(Method, "PointC") == 0)
    {
        PushVector2(L, Object->PointC.x, Object->PointC.y);
    }
    else if (strcmp(Method, "PointD") == 0)
    {
        PushVector2(L, Object->PointD.x, Object->PointD.y);
    }
    else if (strcmp(Method, "Thickness") == 0)
    {
        lua_pushnumber(L, Object->Thickness);
    }
    else if (strcmp(Method, "Filled") == 0)
    {
        lua_pushboolean(L, Object->Filled);
    }
    else if (strcmp(Method, "Filled") == 0)
    {
        PushColor3(L, ImVec4(Object->Color.x, Object->Color.y, Object->Color.z, 0));
    }

    BaseIndex(L, Object, Method);

    return 1;
}

int QuadNewIndex(lua_State* L)
{
    const auto Object = *reinterpret_cast<Quad_t**>(lua_touserdata(L, 1));

    auto Method = lua_tostring(L, 2);

    if (strcmp(Method, "PointA") == 0)
    {
        Object->PointA = ToVec2(L, 3);
    }
    else if (strcmp(Method, "PointA") == 0)
    {
        Object->PointB = ToVec2(L, 3);
    }
    else if (strcmp(Method, "PointC") == 0)
    {
        Object->PointC = ToVec2(L, 3);
    }
    else if (strcmp(Method, "PointD") == 0)
    {
        Object->PointD = ToVec2(L, 3);
    }
    else if (strcmp(Method, "Thickness") == 0)
    {
        Object->Thickness = (float)lua_tonumber(L, 3);;
    }
    else if (strcmp(Method, "Filled") == 0)
    {
        Object->Filled = lua_toboolean(L, 3);
    }

    BaseNewIndex(L, Object, Method);

    return 0;
}

int New(lua_State* L)
{
    auto Type = lua_tostring(L, 1);

    if (strcmp(Type, "Text") == 0)
    {
        auto UserData = static_cast<Text_t**>(lua_newuserdata(L, sizeof(void*)));

        *UserData = new Text_t();   

        auto Obj = *reinterpret_cast<Text_t**>(UserData);

        Obj->Type = 2;

        lua_getfield(L, LUA_REGISTRYINDEX, "DrawingText");
        lua_setmetatable(L, -2);

        Radium::Drawing::RenderingText.push_back(*UserData);

        return 1;
    }
    else if (strcmp(Type, "Line") == 0)
    {
        auto UserData = static_cast<Line_t**>(lua_newuserdata(L, sizeof(void*)));

        *UserData = new Line_t();

        auto Obj = *reinterpret_cast<Line_t**>(UserData);

        Obj->Type = 1;

        lua_getfield(L, LUA_REGISTRYINDEX, "DrawingLine");
        lua_setmetatable(L, -2);

        Radium::Drawing::RenderingLines.push_back(*UserData);

        return 1;
    }
    else if (strcmp(Type, "Circle") == 0)
    {
        auto UserData = static_cast<Circle_t**>(lua_newuserdata(L, sizeof(void*)));

        *UserData = new Circle_t();

        auto Obj = *reinterpret_cast<Circle_t**>(UserData);

        Obj->Type = 3;

        lua_getfield(L, LUA_REGISTRYINDEX, "DrawingCircle");
        lua_setmetatable(L, -2);

        Radium::Drawing::RenderingCircles.push_back(*UserData);

        return 1;
    } 
    else if (strcmp(Type, "Square") == 0)
    {
        auto UserData = static_cast<Square_t**>(lua_newuserdata(L, sizeof(void*)));

        *UserData = new Square_t();

        auto Obj = *reinterpret_cast<Square_t**>(UserData);

        Obj->Type = 4;

        lua_getfield(L, LUA_REGISTRYINDEX, "DrawingSquare");
        lua_setmetatable(L, -2);

        Radium::Drawing::RenderingSquare.push_back(*UserData);

        return 1;
    }
    else if (strcmp(Type, "Quad") == 0)
    {
        auto UserData = static_cast<Quad_t**>(lua_newuserdata(L, sizeof(void*)));

        *UserData = new Quad_t();

        auto Obj = *reinterpret_cast<Square_t**>(UserData);

        Obj->Type = 5;

        lua_getfield(L, LUA_REGISTRYINDEX, "DrawingQuad");
        lua_setmetatable(L, -2);

        Radium::Drawing::RenderingQuads.push_back(*UserData);

        return 1;
    }


    return 0;
}

int GetRenderProperty(lua_State* L)
{
    const auto Object = *reinterpret_cast<BaseDrawing**>(lua_touserdata(L, 1));

    if (Object->Type == 1) // Line
    {
        LineIndex(L);
    }
    else if (Object->Type = 2) // Text
    {
        TextIndex(L);
    }
    else if (Object->Type = 3) // Circle
    {
        CircleIndex(L);
    }
    else if (Object->Type = 4) // Square
    {
        SquareIndex(L);
    }
    else if (Object->Type = 5) // Quad
    {
        QuadIndex(L);
    }

    return 1;
}

int SetRenderProperty(lua_State* L)
{
    const auto Object = *reinterpret_cast<BaseDrawing**>(lua_touserdata(L, 1));

    if (Object->Type == 1) // Line
    {
        LineNewIndex(L);
    }
    else if (Object->Type = 2) // Text
    {
        TextNewIndex(L);
    }
    else if (Object->Type = 3) // Circle
    {
        CircleNewIndex(L);
    }
    else if (Object->Type = 4) // Square
    {
        SquareNewIndex(L);
    }
    else if (Object->Type = 5) // Quad
    {
        QuadNewIndex(L);
    }

    return 1;
}

int ClearDrawCache(lua_State* L)
{
    Radium::Drawing::RenderingCircles.clear();
    Radium::Drawing::RenderingSquare.clear();
    Radium::Drawing::RenderingText.clear();
    Radium::Drawing::RenderingQuads.clear();
    Radium::Drawing::RenderingLines.clear();

    return 0;
}

void Radium::Drawing::Register(lua_State* L)
{


    luaL_newmetatable(L, "DrawingText");
    lua_pushcclosure(L, TextIndex, "", 0);
    lua_setfield(L, -2, "__index");
    lua_pushcclosure(L, TextNewIndex, "", 0);
    lua_setfield(L, -2, "__newindex");


    luaL_newmetatable(L, "DrawingLine");
    lua_pushcclosure(L, LineIndex, "", 0);
    lua_setfield(L, -2, "__index");
    lua_pushcclosure(L, LineNewIndex, "", 0);
    lua_setfield(L, -2, "__newindex");

    luaL_newmetatable(L, "DrawingCircle");
    lua_pushcclosure(L, CircleIndex, "", 0);
    lua_setfield(L, -2, "__index");
    lua_pushcclosure(L, CircleNewIndex, "", 0);
    lua_setfield(L, -2, "__newindex");

    luaL_newmetatable(L, "DrawingSquare");
    lua_pushcclosure(L, SquareIndex, "", 0);
    lua_setfield(L, -2, "__index");
    lua_pushcclosure(L, SquareNewIndex, "", 0);
    lua_setfield(L, -2, "__newindex");

    luaL_newmetatable(L, "DrawingQuad");
    lua_pushcclosure(L, QuadIndex, "", 0);
    lua_setfield(L, -2, "__index");
    lua_pushcclosure(L, QuadNewIndex, "", 0);
    lua_setfield(L, -2, "__newindex");


    lua_newtable(L);
    lua_pushcclosure(L, New, "", 0);
    lua_setfield(L, -2, "new");

    lua_newtable(L);

    lua_pushnumber(L, 0);
    lua_setfield(L, -2, "UI");
    lua_pushnumber(L, 1);
    lua_setfield(L, -2, "System");
    lua_pushnumber(L, 2);
    lua_setfield(L, -2, "Plex");
    lua_pushnumber(L, 3);
    lua_setfield(L, -2, "Monospace");

    lua_setfield(L, -2, "Fonts");

    lua_setglobal(L, "Drawing");

    lua_getglobal(L, "Drawing");
    lua_setreadonly(L, -1, true);

    // I could just use my macro RegisterFunction for this, but this drawing library is rushed, sooo.
    lua_pushcclosure(L, GetRenderProperty, "", 0);
    lua_setglobal(L, "getrenderproperty");

    lua_pushcclosure(L, SetRenderProperty, "", 0);
    lua_setglobal(L, "setrenderproperty");

    lua_pushcclosure(L, ClearDrawCache, "", 0);
    lua_setglobal(L, "cleardrawcache");

    lua_pop(L, lua_gettop(L));
}