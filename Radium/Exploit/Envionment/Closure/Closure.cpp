#include "Closure.hpp"
#include "../../Roblox/Security/Security.hpp"
#include "../../Dependencies/Luau/VM//src/lgc.h"
#include "../../Dependencies/Luau/VM//src/lapi.h"
#include <lualib.h>
#include "../../../Dependencies/Base64/Base64.h"
#include <Luau/Compiler.h>
#include "../../../Dependencies/Luau/VM/src/lfunc.h"

std::map<Closure*, int> ClMap{};

#undef LoadString // Fuck off Windows API!!!

#define RegisterFunction(L, Func, Name) lua_pushcclosure(L, Func, Name, 0); \
lua_setglobal(L, Name);

int IsCClosure(lua_State* L)
{
	luaL_checktype(L, 1, LUA_TFUNCTION);

	lua_pushboolean(L, lua_iscfunction(L, 1));
	return 1;
}

int IsLClosure(lua_State* L)
{
	luaL_checktype(L, 1, LUA_TFUNCTION);

	lua_pushboolean(L, lua_isLfunction(L, 1));
	return 1;
}

int CloneFunction(lua_State* L)
{
	luaL_checktype(L, 1, LUA_TFUNCTION);

	lua_clonefunction(L, 1);	
	return 1;
}

static uintptr_t MaxCapabilities = 0x200000000000003FLL | 0x3FFFFFF00LL;

int LoadString(lua_State* L)
{
	auto Str = lua_tostring(L, 1);

	auto Bytecode = Luau::compile(Str, {}, {});

	Luau::CompileOptions Options{};
	Options.coverageLevel = 0;
	Options.debugLevel = 1;
	Options.optimizationLevel = 1;

	auto Buffer = luau_load(L, "@Radium", Bytecode.c_str(), Bytecode.size(), 0);

	if (Buffer) // Failed
	{
		lua_pushnil(L);
		lua_insert(L, -2);
	}

	Closure* Cl = lua_toclosure(L, -1);

	Radium::Security::SetProtoCapabilities(L, Cl->l.p, &MaxCapabilities);

	return 1;
}

int CheckCaller(lua_State* L)
{
	lua_pushboolean(L, (Radium::Security::GetIdentity(L) == 8));
	return 1;
}

int NewCCHandler(lua_State* L)
{
	CallInfo* Ci = L->ci;

	Closure* CurrentClosure = clvalue(Ci->func);

	auto Args = lua_gettop(L);

	auto SavedCl = ClMap[CurrentClosure];

	lua_getref(L, SavedCl);

	lua_insert(L, 1); // Move the saved result to the base of the stack

	int Result = lua_pcall(L, Args, LUA_MULTRET, 0); // We need to call the function to see if there is an error

	if (Result != 0)
	{
		auto Error = lua_tostring(L, -1);

		if (Error == "attempt to yield across metamethod/C-call boundary") // yield
		{
			return lua_yield(L, 0);
		}

		luaL_error(L, Error);
	}

	return lua_gettop(L);
}

int NewCClosure(lua_State* L)
{
	Closure* Cl = clvalue(index2addr(L, 1));

	if (Cl->isC) // Is this a C Closure?
	{
		lua_pushvalue(L, 1); // We do not need to handle this as this result is NOT a C function, so we push the original
		return 1; // Return 1 result (which is the function provided that is a C Closure)
	}

	int Ref = lua_ref(L, 1); // reference

	lua_pushcclosure(L, NewCCHandler, "", 0); // Push the handler onto the stack

	Closure* Cl2 = clvalue(index2addr(L, -1)); 

	ClMap[Cl2] = Ref; // We need to save the C Closure in the map as a reference

	return 1; // push the c closure handler
}

int Blank(lua_State* L)
{
	return 0;
}

int HookFunction(lua_State* L)
{
	auto ToHook = clvalue(index2addr(L, 1));
	auto HookTo = clvalue(index2addr(L, 2));
	if (ToHook->isC == TRUE) {
		lua_ref(L, 2);
		lua_CFunction func1 = HookTo->c.f;

		Closure* newcl = luaF_newCclosure(L, ToHook->nupvalues, ToHook->env);

		for (int i = 0; i < ToHook->nupvalues; i++) {
			TValue* cl_tval = &ToHook->c.upvals[i];
			TValue* ncl_tval = &newcl->c.upvals[i];

			ncl_tval->value = cl_tval->value;
			ncl_tval->tt = cl_tval->tt;
		}

		lua_CFunction func = ToHook->c.f;
		newcl->c.f = func;		

		ToHook->c.f = Blank; /* we don't wanna break while we set upvalues */

		for (auto i = 0; i < HookTo->nupvalues; i++) {
			TValue* old_tval = &HookTo->c.upvals[i];
			TValue* hook_tval = &HookTo->c.upvals[i];

			old_tval->value = hook_tval->value;
			old_tval->tt = hook_tval->tt;
		}

		ToHook->nupvalues = HookTo->nupvalues;
		ToHook->c.f = func1;

		setclvalue(L, L->top, newcl);
		L->top++;

		return 1;
	}
	else
	{
		lua_ref(L, 2);
		lua_clonefunction(L, 1);

		ToHook->l.p = (Proto*)HookTo->l.p;
		ToHook->nupvalues = HookTo->nupvalues;
		ToHook->env = HookTo->env;
		ToHook->preload = HookTo->preload;
		ToHook->stacksize = HookTo->stacksize;
		
		for (int I = 0; I < HookTo->nupvalues; ++I)
		{
			setobj2n(L, &ToHook->l.uprefs[I], &HookTo->l.uprefs[I]);
		}

		return 1;
	}

	return 0;
}

void Radium::Environment::Cl::Register(lua_State* L)
{
	RegisterFunction(L, IsCClosure, oxorany("iscclosure"));
	RegisterFunction(L, IsCClosure, oxorany("islclosure"));
	RegisterFunction(L, IsCClosure, oxorany("clonefunction"));

	RegisterFunction(L, LoadString, oxorany("loadstring"));

	RegisterFunction(L, NewCClosure, oxorany("newcclosure"));

	RegisterFunction(L, CheckCaller, oxorany("checkcaller"));

	RegisterFunction(L, HookFunction, oxorany("hookfunction"));
}